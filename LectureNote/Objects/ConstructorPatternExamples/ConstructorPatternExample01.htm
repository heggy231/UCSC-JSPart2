<!DOCTYPE html>
<html>
<head>

    <!--In this example, the Person() function takes the place of the factory createPerson() function.-->
    <!--Note that the code inside Person() is the same as the code inside createPerson(), with the-->
    <!--following exceptions:-->
            <!--There is no object being created explicitly.-->
            <!--The properties and method are assigned directly onto the this object.-->
            <!--There is no return statement.-->
    <!--Also note the name of the function is Person with an uppercase P. By convention, constructor-->
    <!--functions always begin with an uppercase letter, whereas nonconstructor functions begin with a-->
    <!--lowercase letter. This convention is borrowed from other OO languages and helps to distinguish-->
    <!--function use in ECMAScript, since constructors are simply functions that create objects.-->
    <!--To create a new instance of Person, use the new operator. Calling a constructor in this manner-->
    <!--essentially causes the following four steps to be taken:-->
    <!--1. Create a new object.-->
    <!--2. Assign the this value of the constructor to the new object (so this points to the new object).-->
    <!--3. Execute the code inside the constructor (adds properties to the new object).-->
    <!--4. Return the new object.-->
    <!--At the end of the preceding example, person1 and person2 are each fi lled with a different instance-->
    <!--of Person. Each of these objects has a constructor property that points back to Person, as follows:-->
    <!--alert(person1.constructor == Person); //true-->
    <!--alert(person2.constructor == Person); //true-->
    <!--The constructor property was originally intended for use in identifying the object type. However, the-->
    <!--instanceof operator is considered to be a safer way of determining type. Each of the objects in this-->
    <!--example is considered to be both an instance of Object and an instance of Person, as indicated by-->
    <!--using the instanceof operator like this:-->
    <!--alert(person1 instanceof Object); //true-->
    <!--alert(person1 instanceof Person); //true-->
    <!--alert(person2 instanceof Object); //true-->
    <!--alert(person2 instanceof Person); //true-->
    <!--Defi ning your own constructors ensures that instances can be identifi ed as a particular type later-->
    <!--on, which is a great advantage over the factory pattern. In this example, person1 and person2 are-->
    <!--considered to be instances of Object, because all custom objects inherit from Object (the specifi cs-->
    <!--of this are discussed later).-->
    <title>Constructor Pattern Example</title>
    <script type="text/javascript">
    
        function Person(name, age, job){
            this.name = name;
            this.age = age;
            this.job = job;

            this.sayName = function(){
                alert(this.name);
            };    
        }
        
        var person1 = new Person("Nicholas", 29, "Software Engineer");
        var person2 = new Person("Greg", 27, "Doctor");
        
        person1.sayName();   //"Nicholas"
        person2.sayName();   //"Greg"
        
        alert(person1 instanceof Object);  //true
        alert(person1 instanceof Person);  //true
        alert(person2 instanceof Object);  //true
        alert(person2 instanceof Person);  //true
        
        alert(person1.constructor == Person);  //true
        alert(person2.constructor == Person);  //true
        
        alert(person1.sayName == person2.sayName);  //false        
        
        
    </script>
</head>
<body>

</body>
</html>